---
  defaultBaseImageVersion: latest
  properties:
  - name: API_KEY
    value: ${API_KEY}
    type: secure
  - name: PROD_CLUSTER_NAME
    value: ${PROD_CLUSTER_NAME}
    type: text
  - name: PROD_REGION_ID
    value: ${PROD_REGION_ID}
    type: text
  stages:
  - name: FETCH
    inputs:
    - type: git
      branch: master
      service: ${GIT_REPO}    
    triggers:
    - type: commit
    properties:
    - name: IMAGE_NAME
      value: ${APP_NAME}
      type: text
    jobs:
    - name: Fetch code
      type: builder
      artifact_dir: ''
      build_type: shell
      script: |+
        #!/bin/bash
        # set -x
  
        # Git repo cloned at $WORKING_DIR, copy into $ARCHIVE_DIR
        # mkdir -p $ARCHIVE_DIR
        # cp -R -n ./ $ARCHIVE_DIR/ || true
  
        # Record git info
        # echo "GIT_URL=${GIT_URL}" >> $ARCHIVE_DIR/build.properties
        # echo "GIT_BRANCH=${GIT_BRANCH}" >> $ARCHIVE_DIR/# build.properties
        # echo "GIT_COMMIT=${GIT_COMMIT}" >> $ARCHIVE_DIR/build.properties
        # echo "SOURCE_BUILD_NUMBER=${BUILD_NUMBER}" >> $ARCHIVE_DIR/build.properties
        # cat $ARCHIVE_DIR/build.properties
  - name: DEPLOY_PREREQS
    properties:
    - name: buildprops
      value: build.properties
      type: file
    - name: DOCKER_ROOT
      value: .
      type: text
    - name: DOCKER_FILE
      value: Dockerfile
      type: text
    - name: PIPELINE_IMAGE_URL
      value: undefined
      type: text
    inputs:
    - type: job
      stage: FETCH
      job: Fetch code
    triggers:
    - type: stage
    jobs:
    - name: Deploy Kafka
      type: deployer
      build_type: kubernetes
      target:
        region_id: ${PROD_REGION_ID}
        api_key: ${API_KEY}
        kubernetes_cluster: ${PROD_CLUSTER_NAME}
      script: |-
        #!/bin/bash
        # kubectl create namespace kafka || true
        # curl -L https://github.com/strimzi/strimzi-kafka-operator/releases/download/0.15.0/strimzi-cluster-operator-0.15.0.yaml \
        #  | sed 's/namespace: .*/namespace: kafka/' \
        #  | kubectl apply -f - -n kafka || true
        # cd reactive
        # kubectl apply -f scripts/kafka-cluster.yaml -n kafka || true
    - name: Deploy Postgres
      type: deployer
      build_type: kubernetes
      target:
        region_id: ${PROD_REGION_ID}
        api_key: ${API_KEY}
        kubernetes_cluster: ${PROD_CLUSTER_NAME}
      script: |-
        #!/bin/bash
        # kubectl create ns my-postgresql-operator-dev4devs-com || true
        # cd reactive
        # kubectl create -f iks-scripts/postgres.yaml || true
  - name: DEPLOY_SERVICES
    properties:
    - name: buildprops
      value: build.properties
      type: file
    - name: MY_REGISTRY_URL
      value: ${REGISTRY_URL}
      type: text
    - name: REGISTRY_NAMESPACE
      value: ${REGISTRY_NAMESPACE}
      type: text
    inputs:
    - type: job
      stage: FETCH
      job: Fetch code
    triggers:
    - type: stage
    jobs:
    - name: Build articles
      type: builder
      build_type: cr
      artifact_dir: .
      target:
        region_id: ${REGISTRY_REGION_ID}
        api_key: ${API_KEY}
      namespace: ${REGISTRY_NAMESPACE}
      image_name: ${APP_NAME}
      script: |
        #!/bin/bash    
        # cd reactive
        # root_folder=$(cd $(dirname $0); cd ..; pwd)
        # MY_REGISTRY_URL=${REGISTRY_URL}

        # cd ${root_folder}/reactive/articles-reactive/src/main/resources
        # sed "s/KAFKA_BOOTSTRAP_SERVERS/my-cluster-kafka-external-bootstrap.kafka:9094/g" application.properties.template > application.properties.temp
        # sed "s/IN_MEMORY_STORE/no/g" application.properties.temp > application.properties.temp2
        # sed "s/POSTGRES_URL/database-articles.my-postgresql-operator-dev4devs-com:5432/g" application.properties.temp2 > application.properties
        
        # cd ${root_folder}/reactive/articles-reactive/
        # ibmcloud cr build -f ${root_folder}/reactive/articles-reactive/Dockerfile --tag $REGISTRY_URL/# $REGISTRY_NAMESPACE/articles-reactive:latest .
    - name: Deploy articles
      type: deployer
      build_type: kubernetes
      target:
        region_id: ${PROD_REGION_ID}
        api_key: ${API_KEY}
        kubernetes_cluster: ${PROD_CLUSTER_NAME}
      script: |+
        #!/bin/bash
        # cd reactive
        # root_folder=$(cd $(dirname $0); cd ..; pwd) 

        # kubectl delete -f ${root_folder}/reactive/articles-reactive/deployment/kubernetes.yaml --ignore-not-found

        # sed "s+articles-reactive:latest+$MY_REGISTRY_URL/$REGISTRY_NAMESPACE/articles-reactive:latest+g" ${root_folder}/reactive/articles-reactive/deployment/kubernetes.yaml > ${root_folder}/reactive/articles-reactive/deployment/temp-kubernetes.yaml 
        # sed "s+Never+Always+g" ${root_folder}/reactive/articles-reactive/deployment/temp-kubernetes.yaml > ${root_folder}/reactive/articles-reactive/deployment/IKS-kubernetes.yaml         
        # kubectl apply -f ${root_folder}/reactive/articles-reactive/deployment/IKS-kubernetes.yaml 
      
        # clusterip=$(ibmcloud ks workers --cluster $PROD_CLUSTER_NAME | awk '/Ready/ {print $2;exit;}') 
        # nodeport=$(kubectl get svc articles-reactive --output 'jsonpath={.spec.ports[*].nodePort}')
        # echo API Explorer: http://${clusterip}:${nodeport}/explorer
    - name: Build authors
      type: builder
      build_type: cr
      artifact_dir: .
      target:
        region_id: ${REGISTRY_REGION_ID}
        api_key: ${API_KEY}
      namespace: ${REGISTRY_NAMESPACE}
      image_name: ${APP_NAME}
      script: |
        #!/bin/bash    
        # cd reactive
        # root_folder=$(cd $(dirname $0); cd ..; pwd)
        # MY_REGISTRY_URL=${REGISTRY_URL}
        
        # cd ${root_folder}/authors-nodejs/
        # ibmcloud cr build -f ${root_folder}/authors-nodejs/Dockerfile --tag $REGISTRY_URL/$REGISTRY_NAMESPACE/authors:1 .
    - name: Deploy authors
      type: deployer
      build_type: kubernetes
      target:
        region_id: ${PROD_REGION_ID}
        api_key: ${API_KEY}
        kubernetes_cluster: ${PROD_CLUSTER_NAME}
      script: |+
        #!/bin/bash
        # cd reactive
        # root_folder=$(cd $(dirname $0); cd ..; pwd) 

        # kubectl delete -f ${root_folder}/authors-nodejs/deployment/IKS-kubernetes.yaml --ignore-not-found

        # sed -e "s|<URL>|notused|g" -e "s|<DB>|local|g" ${root_folder}/authors-nodejs/deployment/deployment.yaml.template > ${root_folder}/authors-nodejs/deployment/temp-deployment.yaml
        # sed "s+authors:1+$MY_REGISTRY_URL/$REGISTRY_NAMESPACE/authors:1+g" ${root_folder}/authors-nodejs/deployment/temp-deployment.yaml > ${root_folder}/authors-nodejs/deployment/IKS-kubernetes.yaml
        # kubectl apply -f ${root_folder}/authors-nodejs/deployment/IKS-kubernetes.yaml
      
        # nodeport=$(kubectl get svc authors --ignore-not-found --output 'jsonpath={.spec.ports[*].nodePort}')
        # clusterip=$(ibmcloud ks workers --cluster $PROD_CLUSTER_NAME | awk '/Ready/ {print $2;exit;}')
        # echo Sample API call: \"curl 'http://${clusterip}:${nodeport}/api/v1/getauthor?name=Niklas%20Heidloff'\"
  